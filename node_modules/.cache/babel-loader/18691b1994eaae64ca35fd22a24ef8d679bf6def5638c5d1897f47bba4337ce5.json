{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringify = void 0;\nconst stringify_1 = require(\"./stringify\");\nconst quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\nfunction stringify(value, replacer, indent, options = {}) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path = [];\n  const stack = new Set();\n  const tracking = new Map();\n  const unpack = new Map();\n  let valueCount = 0;\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000\n  } = options;\n  // Wrap replacer function to support falling back on supported stringify.\n  const valueToString = replacerToString(replacer);\n  // Every time you call `next(value)` execute this function.\n  const onNext = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return;\n    // An undefined key is treated as an out-of-band \"value\".\n    if (key === undefined) return valueToString(value, space, onNext, key);\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n  const builder = references ? (value, key) => {\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\")) {\n      // Track nodes to restore later.\n      if (tracking.has(value)) {\n        unpack.set(path.slice(1), tracking.get(value));\n        // Use `undefined` as temporaray stand-in for referenced nodes\n        return valueToString(undefined, space, onNext, key);\n      }\n      // Track encountered nodes.\n      tracking.set(value, path.slice(1));\n    }\n    return valueToString(value, space, onNext, key);\n  } : (value, key) => {\n    // Stop on recursion.\n    if (stack.has(value)) return;\n    stack.add(value);\n    const result = valueToString(value, space, onNext, key);\n    stack.delete(value);\n    return result;\n  };\n  const result = onNext(value, ROOT_SENTINEL);\n  // Attempt to restore circular references.\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = quote_1.stringifyPath(key, onNext);\n      const valuePath = quote_1.stringifyPath(value, onNext);\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n  return result;\n}\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer) {\n  if (!replacer) return stringify_1.toString;\n  return (value, space, next, key) => {\n    return replacer(value, space, value => stringify_1.toString(value, space, next, key), key);\n  };\n}","map":{"version":3,"names":["stringify_1","require","quote_1","ROOT_SENTINEL","Symbol","stringify","value","replacer","indent","options","space","repeat","path","stack","Set","tracking","Map","unpack","valueCount","maxDepth","references","skipUndefinedProperties","maxValues","valueToString","replacerToString","onNext","key","undefined","length","push","result","builder","pop","has","set","slice","get","add","delete","size","sp","eol","wrapper","entries","keyPath","stringifyPath","valuePath","exports","toString","next"],"sources":["../src/index.ts"],"sourcesContent":["import { toString } from \"./stringify\";\nimport { stringifyPath } from \"./quote\";\nimport { Next, ToString } from \"./types\";\n\nexport interface Options {\n  maxDepth?: number;\n  maxValues?: number;\n  references?: boolean;\n  skipUndefinedProperties?: boolean;\n}\n\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n\n/**\n * Stringify any JavaScript value.\n */\nexport function stringify(\n  value: any,\n  replacer?: ToString | null,\n  indent?: string | number | null,\n  options: Options = {}\n) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path: PropertyKey[] = [];\n  const stack = new Set();\n  const tracking = new Map<any, PropertyKey[]>();\n  const unpack = new Map<PropertyKey[], PropertyKey[]>();\n  let valueCount = 0;\n\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000,\n  } = options;\n\n  // Wrap replacer function to support falling back on supported stringify.\n  const valueToString = replacerToString(replacer);\n\n  // Every time you call `next(value)` execute this function.\n  const onNext: Next = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return;\n\n    // An undefined key is treated as an out-of-band \"value\".\n    if (key === undefined) return valueToString(value, space, onNext, key);\n\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder: Next = references\n    ? (value, key) => {\n        if (\n          value !== null &&\n          (typeof value === \"object\" ||\n            typeof value === \"function\" ||\n            typeof value === \"symbol\")\n        ) {\n          // Track nodes to restore later.\n          if (tracking.has(value)) {\n            unpack.set(path.slice(1), tracking.get(value)!);\n            // Use `undefined` as temporaray stand-in for referenced nodes\n            return valueToString(undefined, space, onNext, key);\n          }\n\n          // Track encountered nodes.\n          tracking.set(value, path.slice(1));\n        }\n\n        return valueToString(value, space, onNext, key);\n      }\n    : (value, key) => {\n        // Stop on recursion.\n        if (stack.has(value)) return;\n\n        stack.add(value);\n        const result = valueToString(value, space, onNext, key);\n        stack.delete(value);\n        return result;\n      };\n\n  const result = onNext(value, ROOT_SENTINEL);\n\n  // Attempt to restore circular references.\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = stringifyPath(key, onNext);\n      const valuePath = stringifyPath(value, onNext);\n\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer?: ToString | null): ToString {\n  if (!replacer) return toString;\n\n  return (value, space, next, key) => {\n    return replacer(\n      value,\n      space,\n      (value: any) => toString(value, space, next, key),\n      key\n    );\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}