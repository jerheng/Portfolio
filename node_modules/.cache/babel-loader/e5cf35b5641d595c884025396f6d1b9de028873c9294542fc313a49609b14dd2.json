{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FunctionParser = exports.dedentFunction = exports.functionToString = exports.USED_METHOD_KEY = void 0;\nconst quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED = {\n  \" \"() {\n    /* Empty. */\n  }\n}[\" \"].toString().charAt(0) === '\"';\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\nconst TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" + \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\nconst functionToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined;\n  // Track in function parser for object stringify to avoid duplicate output.\n  if (name !== undefined) exports.USED_METHOD_KEY.add(fn);\n  return new FunctionParser(fn, space, next, name).stringify();\n};\nexports.functionToString = functionToString;\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nfunction dedentFunction(fnString) {\n  let found;\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n    const [str] = m;\n    if (found === undefined) found = str;else if (str.length < found.length) found = str;\n  }\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\nclass FunctionParser {\n  constructor(fn, indent, next, key) {\n    this.fn = fn;\n    this.indent = indent;\n    this.next = next;\n    this.key = key;\n    this.pos = 0;\n    this.hadKeyword = false;\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name;\n    this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n    this.keyPrefix = key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate = key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n  stringify() {\n    const value = this.tryParse();\n    // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n    return dedentFunction(value);\n  }\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    }\n    // Attempt to remove function prefix.\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    }\n    // Support class expressions.\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n      let offset = this.pos;\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n          this.pos = offset;\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n      if (this.consumeSyntax() === \"()\" && this.consumeSyntax() === \"{}\" && this.pos === this.fnString.length) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n    this.pos = start;\n  }\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   */\n  tryParsePrefixTokens() {\n    let posPrev = this.pos;\n    this.hadKeyword = false;\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n        posPrev = this.pos;\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n        return true;\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n        return token === \"*\";\n    }\n  }\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multi-character operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multi-character sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n  consumeSyntax(wordLikeToken) {\n    const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n    if (!m) return;\n    const [token, match] = m;\n    this.consumeWhitespace();\n    if (match) return wordLikeToken || match;\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n      case \"`\":\n        return this.consumeTemplate();\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n    return token;\n  }\n  consumeSyntaxUntil(startToken, endToken) {\n    let isRegExpAllowed = true;\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n      if (token === \"/\" && isRegExpAllowed && this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n  consumeMatch(re) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n  consumeRegExp(re, token) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n  /**\n   * Advance the parser past a template string.\n   */\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n      return;\n    }\n  }\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n}\nexports.FunctionParser = FunctionParser;","map":{"version":3,"names":["quote_1","require","METHOD_NAMES_ARE_QUOTED"," ","toString","charAt","FUNCTION_PREFIXES","Function","GeneratorFunction","AsyncFunction","AsyncGeneratorFunction","METHOD_PREFIXES","TOKENS_PRECEDING_REGEXPS","Set","split","exports","USED_METHOD_KEY","WeakSet","functionToString","fn","space","next","key","name","undefined","add","FunctionParser","stringify","dedentFunction","fnString","found","line","slice","m","exec","str","length","join","constructor","indent","pos","hadKeyword","prototype","call","fnType","keyQuote","quoteKey","keyPrefix","isMethodCandidate","value","tryParse","getPrefix","result","tryStrippingName","prevPos","consumeSyntax","tryParsePrefixTokens","offset","substr","start","prefix","isValidVariableName","posPrev","token","wordLikeToken","consumeMatch","match","consumeWhitespace","consumeSyntaxUntil","consumeTemplate","consumeRegExp","startToken","endToken","isRegExpAllowed","has","re"],"sources":["../src/function.ts"],"sourcesContent":["import { Next, ToString } from \"./types\";\nimport { quoteKey, isValidVariableName } from \"./quote\";\n\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED =\n  {\n    \" \"() {\n      /* Empty. */\n    },\n  }[\" \"]\n    .toString()\n    .charAt(0) === '\"';\n\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \",\n};\n\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\",\n};\n\nconst TOKENS_PRECEDING_REGEXPS = new Set(\n  (\n    \"case delete else in instanceof new return throw typeof void \" +\n    \", ; : + - ! ~ & | ^ * / % < > ? =\"\n  ).split(\" \")\n);\n\n/**\n * Track function parser usage.\n */\nexport const USED_METHOD_KEY = new WeakSet<(...args: unknown[]) => unknown>();\n\n/**\n * Stringify a function.\n */\nexport const functionToString: ToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined;\n\n  // Track in function parser for object stringify to avoid duplicate output.\n  if (name !== undefined) USED_METHOD_KEY.add(fn);\n\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nexport function dedentFunction(fnString: string) {\n  let found: string | undefined;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n\n    if (found === undefined) found = str;\n    else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\n/**\n * Function parser and stringify.\n */\nexport class FunctionParser {\n  fnString: string;\n  fnType: keyof typeof FUNCTION_PREFIXES;\n  keyQuote: string | undefined;\n  keyPrefix: string;\n  isMethodCandidate: boolean;\n\n  pos = 0;\n  hadKeyword = false;\n\n  constructor(\n    public fn: (...args: unknown[]) => unknown,\n    public indent: string,\n    public next: Next,\n    public key?: string\n  ) {\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name as keyof typeof FUNCTION_PREFIXES;\n    this.keyQuote = key === undefined ? \"\" : quoteKey(key, next);\n    this.keyPrefix =\n      key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate =\n      key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse();\n\n    // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    }\n\n    // Attempt to remove function prefix.\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    }\n\n    // Support class expressions.\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (\n        this.consumeSyntax() === \"()\" &&\n        this.consumeSyntax() === \"{}\" &&\n        this.pos === this.fnString.length\n      ) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   */\n  tryParsePrefixTokens(): boolean {\n    let posPrev = this.pos;\n\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n\n        posPrev = this.pos;\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n        return true;\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multi-character operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multi-character sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n  consumeSyntax(wordLikeToken?: string) {\n    const m = this.consumeMatch(\n      /^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/\n    );\n\n    if (!m) return;\n\n    const [token, match] = m;\n    this.consumeWhitespace();\n\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n      case \"`\":\n        return this.consumeTemplate();\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken: string, endToken: string): string | undefined {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (\n        token === \"/\" &&\n        isRegExpAllowed &&\n        this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)\n      ) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re: RegExp) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n  consumeRegExp(re: RegExp, token: string): string | undefined {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n\n  /**\n   * Advance the parser past a template string.\n   */\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}